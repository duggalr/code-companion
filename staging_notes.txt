TODO:
- setup celery and redis (<-- literally should be prehooks before application starts)
- update the env variables accordingly

TODO:
- run new tests in aws staging and ensure they work
- from there --> create staging frontend on vercel and link to aws endpoint

**Start here**:
    - create basic tests for the staging url to ensure it works
    - from there, setup the staging frontend in vercel as shown below
        - **get all staging with custom domain complete today**


- setup staging for frontend in vercel
- update urls with .env variables to test the staging api
- ^get staging to completely work
    - then setup CI/CD and figure out how to do the production environment



Staying up to date with all the recent new agents in various benchmarks
- Starting with:
    - https://www.swebench.com/index.html
    - https://github.com/openai/mle-bench/
Simulations
Berkeley Hackathon:
- https://rdi.berkeley.edu/llm-agents-hackathon/tracks/applications_track/


TODO: **need to make a document mapping this out further**
    Write-up for Companion for personal blog + video
    - writeups for each major release (<-- blogs)
    -- Write the first version public announcement
        - The problem, why I built this, the engineering design, tracking user data, next steps/ideas

    -- Writing something every 2 weeks --> Sharing this publicly

    TODO: (looking around)
    - Take a look of the benchmarking
        - how is the SWE-bench defined, understanding the benchmark/evaluation
        - Run it locally and test on models

    - Sharing interesting projects I find


# TODO: lambda.chat
    - swap out lambda chat endpoint for new endpoint and test to ensure solid
    - metrics + grafana setup



     # while True:
        #     # # Receive data from client
        #     # data = await websocket.receive_json()
        #     # # print('Received data:', data)
        #     async for text in generate_async_response_stream():
        #         # print('Response', text)
        #         # print('Is None:', text is None)
        #         # await websocket.send_text(text)
        #         if text is None:
        #             await websocket.send_text('MODEL_GEN_COMPLETE')
        #         else:
        #             await websocket.send_text(text)


ws://code-companion-three.vercel.app/ws_handle_chat_response
https://code-companion-three.vercel.app

{/* TODO: start here and finalize along with fixing the toggle dark/light; test and finalize everything else; then, staging + production + video/blog */}


    // const [theme, setTheme] = useState(localStorage.getItem('theme') || 'light');

    // // Listen to theme changes and update localStorage
    // useEffect(() => {
    //     localStorage.setItem('theme', theme);
    // }, [theme]);

    // useEffect(() => {
    //   // When the component mounts, read the current theme from localStorage
    //   const savedTheme = localStorage.getItem('theme') || 'light';
  
    //   // Set the editor's theme based on the saved theme
    //   if (savedTheme === 'dark') {
    //     monaco.editor.setTheme('minimalistDark');
    //   } else {
    //     monaco.editor.setTheme('minimalistLight');
    //   }
    // }, []);



        // // Set the initial theme based on localStorage
        // const savedTheme = localStorage.getItem('theme') || 'light';
        // monaco.editor.setTheme(savedTheme === 'dark' ? 'minimalistDark' : 'minimalistLight');

        // // Listen for theme change event
        // const handleThemeChange = (e) => {
        //     const newTheme = e.detail;
        //     monaco.editor.setTheme(newTheme === 'dark' ? 'minimalistDark' : 'minimalistLight');
        // };

        // window.addEventListener('themeChange', handleThemeChange);

        // // Clean up the event listener when the component unmounts
        // return () => {
        //     window.removeEventListener('themeChange', handleThemeChange);
        // };
